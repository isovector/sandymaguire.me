<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Edsger Dijkstra (A Discipline of Programming (Prentice-Hall Series in Automatic Computation) (1976)) &larr; We Can Solve This</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
        <link href="/atom.xml" rel="alternate" title="We Can Solve This - Atom" type="application/atom+xml">
        <link href="/feed.rss" rel="alternate" title="We Can Solve This - RSS" type="application/rss+xml">

        <link href='http://fonts.googleapis.com/css?family=Amiri|Muli' rel='stylesheet' type='text/css'>
        <link href="/css/style.css" type="text/css" rel="stylesheet" />

        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/manifest.json" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="theme-color" content="#ffffff" />

        <script type="text/javascript" src="/js/baseline.js"></script>
        </head>
        <body>

    <header>
      <h1>Edsger Dijkstra (A Discipline of Programming (Prentice-Hall Series in Automatic Computation) (1976))</h1>
    </header>

    <div id="boxes">
    <div id="flex">
    <div id="nav">
      <ul>
        <li><a href="/blog/archives">Essays</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/now">Now</a></li>
        <li><a href="/top-posts">Best Of</a></li>
        <li><a href="/book-reviews">Book Reviews</a></li>
        <li><a href="/books">Book Quotes</a></li>
      </ul>

      <p>Built with love by Sandy Maguire.</p>
      <p>&copy; 2011-2025</p>
    </div>
    <div id="main">
      <div class="content">

         <div class="meta"></div>

<article>
    <p>The moral of the story can only be that a nontrivial algorithm is just nontrivial, and that its final description in a progranlming language is highly compact compared to the considerations that justify its design: the shortness of the final text should not mislead us!
</p>
    <hr class="chill" />
    <p>the accusation that &quot;I had made programming difficult&quot;. But the difficulty has always been there, and only by making it visible can we hope to become able to design programs with a high confidence level, rather than &quot;smearing code&quot;, i.e., producing texts with the status of hardly sup- ported conjectures that wait to be killed by the first counterexample.
</p>
    <hr class="chill" />
    <p>None of the programs in this monograph, needless to say, has been tested on a machine.
</p>
    <hr class="chill" />
    <p>When programming languages emerged, the &quot;dynamic&quot; nature of the assignment statement did not seem to fit too well into the &quot;static&quot; nature of traditional mathematics.
</p>
    <hr class="chill" />
    <p>one&quot;, but even &quot;the true one&quot;. In view of the fact that we cannot even define what a Turing machine is supposed to do without appeal- ing to the notion of repetition,
</p>
    <hr class="chill" />
    <p>For the absence of a bibliography I offer neither explanation nor apology.
</p>
    <hr class="chill" />
    <p>Executional abstraction is so basic to the whole notion of &quot;an algorithm&quot; that it is usually taken for granted and left unmentioned. Its purpose is to map different computations upon each other. Or, to put it in another way, it refers to the way in which we can get a specific computation within our intellectual grip by considering it as a member of a large class of different computations;
</p>
    <hr class="chill" />
    <p>The simplicity of the cardboard mechanism is a great virtue, but it is overshadowed by two drawbacks, a minor one and a major one. The minor one is that the mechanism can, indeed, be used for producing the greatest common divisor of 111 and 259, but for very little else. The major drawback, however, is that, no matter how carefully we inspect the construction of the mechanism, our confidence that it produces the correct answer can only be based on our faith in the manufacturer: he may have made an error, either in the design of his machine or in the production of our particular copy.
</p>
    <hr class="chill" />
    <p>We could do the arith- metic ourselves, but of course it is better if the machine could do that for us. If we then want to believe the answer, we should be able to convince ourselves that the machine compares and subtracts correctly.
</p>
    <hr class="chill" />
    <p>Instead of considering the single problem of how to compute the GCD(111, 259), we have generalized the problem and have regarded this as a specific instance of the wider class of problems of how to compute the GCD(X, Y).
</p>
    <hr class="chill" />
    <p>when asked to produce one or more results, it is usual to generalize the problem and to consider these results as specific instances of a wider class. But it is no good just to say that everything is a special instance of something more general!
</p>
    <hr class="chill" />
    <p>The machine that upon request can produce as answer the value of all sorts of funny functions of 111 and 259 becomes harder to verify as the collection of functions grows.
</p>
    <hr class="chill" />
    <p>The freedom to replace one pebble with a two-dimensional freedom of position by two half-pebbles with a one-dimensional freedom of position is exploited in the suggested two-register machine. From a technical point of view this is very attractive; one only needs to build registers able to distin- guish between 500 different cases (&quot;values&quot;) and by just combining two such registers, the total number of different cases is squared! This multi- plicative rule enables us to distinguish between a huge number of possible total states with the aid of a modest number of components with only a modest number of possible states each.
</p>
    <hr class="chill" />
    <p>we have insisted upon a compact justification for the rules of the game and this implies that the rules of the game themselves have to be compact.
</p>
    <hr class="chill" />
    <p>It is a fascinating thought that this chapter could have been written while Euclid was looking over my shoulder.
</p>
    <hr class="chill" />
    <p>The power of a formal notation should manifest itself in the achievements we could never do without it!
</p>
    <hr class="chill" />
    <p>such a notation technique should enable us to define algorithms so unambiguously that, given an algorithm described by it and given the values for the arguments (the input), there should be no doubt or uncertainty as to what the corresponding answers (the output) should be.
</p>
    <hr class="chill" />
    <p>It is then con- ceivable that the computation is carried out by an automaton that, given (the formal description of) the algorithm and the arguments, will produce the answers without further human intervention. Such automata, able to carry out the mutual confrontation of algorithm and argument with each other, have indeed been built. They are called &quot;automatic computers&quot;.
</p>
    <hr class="chill" />
    <p>natural languages, non- formalized as they are, derive both their weakness and their power from their vagueness and imprecision.)
</p>
    <hr class="chill" />
    <p>the fact that programming languages could be used as a vehicle for instructing existing automatic compu- ters, has for a long time been regarded as their most important property.
</p>
    <hr class="chill" />
    <p>the fact that programming languages could be used as a vehicle for instructing existing automatic compu- ters, has for a long time been regarded as their most important property. The efficiency with which existing automatic computers could execute programs written in a certain language became the major quality criterion for that language!
</p>
    <hr class="chill" />
    <p>it is not unusual to find anomalies in existing machines truthfully reflected in programming languages, this at the expense of the intellectual manageability of the programs expressed in such a language (as if programming without such anomalies was not already diffi- cult enough
</p>
    <hr class="chill" />
    <p>our algorithms could actually be carried out by a computer as a lucky accidental circumstance that need not occupy a central position in our considerations.
</p>
    <hr class="chill" />
    <p>If you are convinced of the usefulness of the procedure concept and are surrounded by implementations in which the overhead of the procedure mechanism imposes too great a penalty, then blame these inadequate implementations instead of raising them to the level of standards!
</p>
    <hr class="chill" />
    <p>I view a programming language primarily as a vehicle for the description of (potentially highly sophisticated) abstract mechanisms.
</p>
    <hr class="chill" />
    <p>the algorithm&#39;s outstanding virtue is the potential compactness of the arguments on which our confidence in the mechanism can be based. Once this compactness is lost, the algorithm has lost much of its &quot;right of existence&quot; and therefore we shall consciously aim at retaining that compactness.
</p>
    <hr class="chill" />
    <p>They are truly &quot;names&quot; in the sense that by inspecting the sequence &quot;one, two, three&quot; no rule enables us to derive that the next one will be &quot;four&quot;. You really must know that. (At an age that I knew perfectly well how to count -in Dutch- I had to learn how to count in English, and during a school test no clever inspection of the words &quot;seven&quot; and &quot;nine&quot; would enable me to derive how to spell &quot;eight&quot;, let alone how to pronounce it!)
</p>
    <hr class="chill" />
    <p>The total number of points in that state space is the product of the number of points in the state spaces from which it has been built (that is why it is called the Cartesian product). Whether such a register is considered as a single variable with 10 8 different possible values, or as a composite variable composed out of eight different ten-valued variables called &quot;wheels&quot; depends on our interest in the thing.
</p>
    <hr class="chill" />
    <p>Many a programmer&#39;s decisions have to do with the introduction of state spaces with coordinate systems that are appropriate for his goal
</p>
    <hr class="chill" />
    <p>the design of such a system is a goal-directed activity, in other words that we want to achieve something with the system.
</p>
    <hr class="chill" />
    <p>the set of possible post-conditions is in general so huge that this knowledge in tabular form (i.e. in a table with an entry for each R wherein we would find the corresponding wp(S, R» would be utterly unmanageable, and therefore useless.
</p>
    <hr class="chill" />
    <p>For a fixed mechanism S such a rule, which is fed with the predicate R denoting the post-condition and delivers a predicate wp(S, R) denoting the corresponding weakest precondition, is called &quot;a predicate transformer&quot;. When we ask for the definition of the semantics of the mechanism S, what we really ask for is its corresponding predicate transformer.
</p>
    <hr class="chill" />
    <p>Secondly -and I feel tempted to add &quot;thank goodness&quot;- we are often not interested in the complete semantics of a mechanism. This is because it is our intention to use the mechanism S for a specific purpose only, viz. for establishing the truth of a very specific post-condition R for which it has been designed. And even for that specific post-condition R, we are often not interested in the exact form ofwp(S, R); often we are content with a stronger condition P,
</p>
    <hr class="chill" />
    <p>For many years thereafter I have regarded the irreproducibility of the behaviour of the nondeterministic machine as an added complication that should be avoided whenever possible. Interrupts were nothing but a curse inflicted by the hardware engineers upon the poor software makers!
</p>
    <hr class="chill" />
    <p>program testing can be quite effective for showing the presence of bugs, but is hopelessly inadequate for showing their absence.
</p>
    <hr class="chill" />
    <p>any design discipline must do justice to the fact that the design of a mechanism that is to have a purpose must be a goal-directed activity. In our special case it means that we can expect our post-condition to be the starting point of our design considerations. In a sense we shall be &quot;working backwards&quot;.
</p>
    <hr class="chill" />
    <p>in practice the notion of a liberal pre-condition is a quite useful one. If one implements, for instance, a programming language, one will not prove that the implementation executes any correct program correctly; one should be happy and content with the assertion that no correct program will THE CHARACTERIZATION OF SEMANTICS 23 be processed incorrectly without warning-provided,
</p>
    <hr class="chill" />
    <p>Once this tool has been developed, we shall consider how it can be bent into one allowing us to talk about liberal pre-conditions to the extent we are interested in them.
</p>
    <hr class="chill" />
    <p>If one so desires one can approach the problem of programming language design from out of that corner. In such an approach the -rather formal- starting point is that the rules for constructing predicate transformers must be such that whatever can be constructed by applying them must be a predic- ate transformer enjoying the properties 1 through 4 from the previous chapter &quot;The Characterization of Semantics&quot;, for if they don&#39;t, you are just massag- ing predicates in a way such that they can no longer be interpreted as post- conditions and corresponding weakest preconditions respectively.
</p>
    <hr class="chill" />
    <p>Note. Those who think it a waste of characters to introduce an explicit name such as &quot;skip&quot; for the empty statement while &quot;nothing&quot; expresses its semantics so eloquently, should realize that the decimal number system was only possible thanks to the introduction of the character &quot;0&quot; for the concept zero.
</p>
    <hr class="chill" />
    <p>We shall not try to demonstrate this and leave it to the reader&#39;s taste whether he will regard this as a trivial or as a deep mathematical result.
</p>
    <hr class="chill" />
    <p>At first sight such a cyclic definition seems frightening, but upon closer inspection we can convince ourselves that, at least from a syntactic point of view, there is nothing wrong with it.
</p>
    <hr class="chill" />
    <p>It is tradition to denote the composite object cor- responding to that predicate transformer by &quot;Sl; S2&quot; and we define wp(&quot;Sl; S2&quot;, R) == wp(Sl, wp(S2, R»
</p>
    <hr class="chill" />
    <p>Wtf this is cps but why? Doesnt square with my understanding of what were defining
</p>
    <hr class="chill" />
    <p>A third reason is precisely that most of us are so famiJiar with them that we have forgotten how, a long time ago, we have convinced ourselves of their correctness:
</p>
    <hr class="chill" />
    <p>There has been a time that technical considerations exerted a very strong pressure towards minimization of the number of flip-flops used and to use more than six flip- flops to build a finite-state machine with at most 64 states was at that time regarded, if not as a crime, at least as a failure.
</p>
    <hr class="chill" />
    <p>They were conceived at a time when it was the general opinion that it was our program&#39;s purpose to instruct our machines, in contrast to the situation of today in which more and more people are leaning towards the opinion that it is our machines&#39; purpose to execute our programs.
</p>
    <hr class="chill" />
    <p>Any effort to evaluate the value of a variable having that unique, special value &quot;UNDEFINED&quot; can then be honoured by program abortion and an error message. Upon closer scrutiny, however, this simple proposal leads to logical problems; for instance, it is then impossible to copy the values of any set of variables. Efforts to remedy that situation include, for instance, the possibility to inspect whether a value is defined or not. But such ability to manipulate the special value -e.g. the value &quot;NIL&quot; for a pointer pointing nowhere- easily leads to confusions and contradictions: one might discover a case of bigamy when meeting two bachelors married to the same &quot;nobody&quot;. Another way out, abolishing the variables with undefined values, has been the implicit initialization upon block entry not with a very special, but with a very common, almost &quot;neutral&quot; value (say &quot;zero&quot; for all integers and &quot;true&quot; for all booleans). But this, of course, is only fooling oneself; now detection of a very common programming error has been made impossible by making all sorts of nonsensical programs artificially into legal ones.
</p>
    <hr class="chill" />
    <p>The fact that the three repetitive constructs, separated by semicolons, now appear in an arbitrary order does not worry me: it is the usual form of over-specifica- tion that we always encounter in sequential programs prescribing things in succession that could take place concurrently.
</p>
    <hr class="chill" />
    <p>The moral of the story is that once one has an algorithm, one should not be content with it too soon, but investigate whether it can still be massaged. When one has made such recon- siderations a habit, it is unlikely that the notion of &quot;ultraviolet&quot; would in this example have escaped one&#39;s attention.
</p>
    <hr class="chill" />
    <p>The concerns to be separated could be called &quot;the mathematical concerns&quot; and &quot;the engineering concerns&quot;. With the mathematical concerns I refer to the program&#39;s correctness; with the engineering concerns I refer mainly to the various cost aspects -such as storage space and computation time - associated \vith program execution.
</p>
    <hr class="chill" />
    <p>There exist, regretfully enough, machines in which the continuous check that the simulation of the behaviour of the UM is not beyond their capacity is so time-consuming, that this check is suppressed for the supposed sake of efficiency: whenever the capacity would be exceeded by a correct execution, they just continue -for the supposed sake of convenience- incorrectly.
</p>
    <hr class="chill" />
    <p>Once the automatic computer was there, it was not only a new tool, it was also a new challenge and, if the tool was without precedent, so was the challenge.
</p>
    <hr class="chill" />
    <p>we are faced with the challenge of discovering new (desirable) applications, and this is not easy, because the applications could be as revo- lutionary as the tool itself.
</p>
    <hr class="chill" />
    <p>For anyone interested in the human ability to think difficult thoughts (by avoiding unmastered complexity) the programming task provides an ideal proving ground.
</p>
    <hr class="chill" />
    <p>The purpose of thinking is to reduce the detailed reasoning needed to a doable amount, and a separation of concerns is the way in which we hope to achieve this reduction.
</p>
    <hr class="chill" />
    <p>The crucial choice is, of course, what aspects to study &quot;in isolation&quot;, how to disentangle the original amorphous knot of obligations, constraints, and goals into a set of &quot;concerns&quot; that admit a reasonably effective separa- tion.
</p>
    <hr class="chill" />
    <p>Bertrand Russell&#39;s verdict: &quot;The advan- tages of the method of postulation are great; they are the same as the advan- tages of theft over honest toiL&quot;.
</p>
    <hr class="chill" />
    <p>My interest in formal correctness proofs was, and mainly still is, a derived one. I had witnessed many discussions about programming languages and programming style that were depressingly inconclusive. The cause of the difficulty to come to a consensus was the absence of a few effective yardsticks in whose relevance we could all believe. (Too much we tried to settle in the name of convenience for the user, but too often we confused &quot;convenient&quot; with &quot;conventional&quot;, and that latter criterion is too much dependent on each person&#39;s own past.)
</p>
    <hr class="chill" />
    <p>And, above all, length of a formal proof i an objective criterion: this objectivity has probably been more effective in reaching a comfortable consensus than anything else, cer- tainly more effective than eloquence could ever have been. The primary interest was not in formal correctness proofs, but in a discipline that would assist us in keeping our programs intelligible, understandable, and intellec- tually manageable.
</p>
    <hr class="chill" />
    <p>I prefer to view formal methods as tools, the use of which might be helpful. I have tried to present programming rather as a discipline than as a craft.
</p>
    <hr class="chill" />
    <p>it does not suffice to design a mechanism of which we hope that it will meet its requirements, but that we must design it in such a form that we can convince ourselves -and anyone else for that matter- that it will, indeed, meet its requirements.
</p>
    <hr class="chill" />
    <p>As remarked above, the purpose of thinking is to reduce the detailed reasoning needed to a doable amount. The burning question is: can &quot;think- ing&quot; in this sense be taught? If I answer &quot;No&quot; to this question, one may well IN RETROSPECT 217 ask why I have written this book in the first place; if I answer &quot;Yes&quot; to this question, I would make a fool of myself, and the only answer left to me is &quot;Up to a point.
</p>
    <hr class="chill" />
</article>

      </div>
    </div>
    </div>

        <div class="comments">
<script src="https://utteranc.es/client.js"
        repo="isovector/sandymaguire.me"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>

    </div>
    </div>
  </body>
</html>

