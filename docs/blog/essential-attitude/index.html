<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>The Essential Attitude &larr; We Can Solve This</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
        <link href="/atom.xml" rel="alternate" title="We Can Solve This - Atom" type="application/atom+xml">
        <link href="/feed.rss" rel="alternate" title="We Can Solve This - RSS" type="application/rss+xml">

        <link href='http://fonts.googleapis.com/css?family=Amiri|Muli' rel='stylesheet' type='text/css'>
        <link href="/css/style.css" type="text/css" rel="stylesheet" />

        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/manifest.json" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="theme-color" content="#ffffff" />

        <script type="text/javascript" src="/js/baseline.js"></script>
        </head>
        <body>

    <header>
      <h1>The Essential Attitude</h1>
    </header>

    <div id="boxes">
    <div id="flex">
    <div id="nav">
      <ul>
        <li><a href="/blog/archives">Essays</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/now">Now</a></li>
        <li><a href="/top-posts">Best Of</a></li>
        <li><a href="/book-reviews">Book Reviews</a></li>
        <li><a href="/books">Book Quotes</a></li>
      </ul>

      <p>Built with love by Sandy Maguire.</p>
      <p>&copy; 2011-2023</p>
    </div>
    <div id="main">
      <div class="content">

         <div class="meta">November  2, 2015</div>

<article>
    <p>Something I probably should have remembered to write yesterday: it’s officially <a href="http://nanowrimo.org/">National Novel Writing Month</a>. I’m not actually writing a novel this month, but instead am writing the equivalent number of words as blog posts. Unfortunately for you, there are no rewards <a href="http://sandymaguire.me/blog/nanowrimo">this time around</a>, but you can still cheer me on if you want by enjoying my content if it’s good, and telling me if it isn’t.</p>
<p>I’m kind of cheating this year, since <code>wc -w posts/2015-11-*</code> is how I’m counting words across my blog posts. That’s going to include markdown semantics, but I’m going to count it anyway because anything else would involve doing work. In my defense, writing blog posts is probably harder than writing a novel I’d never publish; my last NaNoWriMo had a chapter in a children’s book on advanced mathematics, and one narrated by a hard-boiled detective down in his luck who had somehow found his way into Narnia.</p>
<p>Since I’d be relatively embarrassed to write a blog post about the exact details on how I put peanut butter on my sandwiches<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, there’s probably more cognitive effort required here than in a novel. That being said, since I have a full time job, a somewhat active social life, am trying to pick up the guitar right now, and the average blog post takes me 10 hours to write, try not to expect too much from the posts this month.</p>
<p>But I’ll do my best.</p>
<h2 id="introduction">Introduction</h2>
<p><a href="http://sandymaguire.me/blog/vim-is-not-about-hjkl">Yesterday’s post</a> had significantly better responses than I was expecting, and, not being one to miss an opportunity to milk a dead horse (or mix metaphors), I thought we’d continue today along the same theme.</p>
<p>I have to admit. I have a pet peeve. It’s when my heroes who are really good at something don’t post any resources on how they go about being really good at those things. I’m not the world’s best vim user, but I’d say I’m probably above average, and so this blog post is going to be my modest attempt to not contribute to my personal annoyances.</p>
<p>While my previous post was more about the motivation behind getting good at vim, this one aims to be more <em>how I actually do it</em>. If that doesn’t interest you, I’ll get back to more regularly scheduled blogging in a few days when I’ve got some time to do some thought cataloging.</p>
<p>Without further ado: getting good at vim.</p>
<h2 id="the-basics">The Basics</h2>
<p>Before getting too heavy with modding vim, you should probably get an idea of what you can do without mods. A really good starting place for this is the <code>vimtutor</code> program, which will take maybe a half hour, but ensure that you have the fundamentals.</p>
<p>There are two simple concepts you should grasp in vim: movements and operators.</p>
<h3 id="movements">Movements</h3>
<p>Movements are your basic way of getting around. The ones you definitely know about are <code>hjkl</code>, which move you one character at a time. Most of the time, however, you want to be moving more than one character at a time. Here are some movements you might <em>not</em> know about, sorted roughly in order of ascending distance.</p>
<ul>
<li><code>e</code>: move to the end of the current word</li>
<li><code>w</code>: move a vim-word forward (vim has a strange idea of what constitutes a word)</li>
<li><code>W</code>: move a human-word forward</li>
<li><code>tx</code>: move to just before the next ‘x’ character (mnemonic: un<strong>t</strong>il)</li>
<li><code>fy</code>: move to the next ‘y’ character (mnemonic: <strong>f</strong>ind)</li>
<li><code>$</code>: move to the end of the line (mnemonic: same as in regex)</li>
<li><code>)</code>: move to the end of this sentence</li>
<li><code>])</code>: move to the next unmatched ‘)’</li>
<li><code>]s</code>: move to the next misspelled word</li>
<li><code>}</code>: move to the end of this paragraph</li>
<li><code>]}</code>: move to the next unmatched ‘}’</li>
<li><code>/regex\&lt;CR&gt;</code>: move to the next occurrence of a regular expression</li>
<li><code>G</code>: move to the end of the file</li>
</ul>
<p>In addition, all of these movements can be prefixed with a number, to repeat the movement that many times. For example, <code>5}</code> moves you down five paragraphs; <code>3ti</code> moves you ahead three ‘i’s (something I always mess up: <code>t3i</code> moves to the next ’3’ and enters insert mode). Putting a number before <code>G</code> will move you to that line number.</p>
<p>In order to move backwards similar amounts, you can use <code>T</code> or <code>F</code>, for the first two commands, or switch the directions of any of the brackety-type ones (eg. <code>[(</code> moves back to the previous unmatched ‘(’).</p>
<h3 id="operators">Operators</h3>
<p>Operators are normal-mode commands. You’re probably familiar with a few of them. Here’s a random list of some that I use often:</p>
<ul>
<li><code>d</code>: delete</li>
<li><code>y</code>: yank</li>
<li><code>c</code>: change</li>
<li><code>=</code>: re-indent</li>
<li><code>gq</code>: wrap text</li>
<li><code>gc</code>: comment (if you install <a href="https://github.com/tpope/vim-commentary">vim-commentary</a> later)</li>
</ul>
<p>Pressing the last letter of the operator again will apply the operator to the current line (this is why <code>dd</code> deletes a line). With the notable exception of yanking, using a capital letter for the operator will act on the <em>rest</em> of the line.</p>
<p>But really, the interesting part of operators is that they compose with movements. <code>ct(</code> deletes everything up until the next ‘(’ character and leaves you in insert mode to replace it how you please. <code>y2{</code> yanks the text earlier in your current paragraph, and the paragraph above that. <code>=G</code> fixes your indenting for the rest of the file.</p>
<p>This system is really cool, because it means you can learn movements individually, and you can learn operators on their own, but as soon as you learn a new one, it works with all the knowledge you’ve already solidified. Learning a new movement makes all of your operators that much stronger; learning a new operator will play nicely with all the movements you know.</p>
<p>In editors that aren’t vim, getting all of these combinations requires writing <span class="math inline"><em>O</em>(|<em>m</em>|⋅|<em>o</em>|)</span> functions, but in vim this is only <span class="math inline"><em>O</em>(|<em>m</em>|+|<em>o</em>|)</span> pieces of code in vim. You might not appreciate the difference in this (after all, it’s the programmers of the editor who have to code them, not you). The benefit is twin-fold: there’s less for you to remember, and when you start writing your own operators or movements, you don’t need to worry about getting all the edge cases. It Just Works™.</p>
<p>In addition to movements, all operators also support what are known as <em>text objects</em>: sequences of characters which are somehow context-aware. Text objects usually come in two flavors of the same object: <em>in</em> and <em>around</em> (or <em>a</em>).</p>
<p>Text objects don’t exist by themselves, so I’ll present a few of them here in terms of random operators:</p>
<ul>
<li><code>gqip</code>: reflow the text which comprises of the paragraph I’m currently in</li>
<li><code>di}</code>: delete the text inside of (but excluding) the pair of braces I’m currently in</li>
<li><code>da)</code>: delete the text inside of (and including) the pair of parentheses I’m currently in</li>
<li><code>cis</code>: change inside sentence</li>
<li><code>yab</code>: yank a block (what a “block” is is language dependent)</li>
</ul>
<p>As as a general rule, the <strong>i</strong> versions of text objects don’t operate on the surround context, but the <strong>a</strong> versions do. What context means for a particular text object isn’t always exactly what you’d expect it to be a priori, but it usually works well enough.</p>
<p>Text objects are generally more useful than movements, and there are like a million plugins that add new ones. As such, finding text objects is a great way to build your editing speed.</p>
<h2 id="infrastructure">Infrastructure</h2>
<p>Cool. So now that we have basic vim out of the way, let’s get started building some infrastructure for our modifications.</p>
<p>First of all, go install a plugin manager. I recommend <a href="https://github.com/junegunn/vim-plug">vim-plug</a> because it’s what I use and I don’t know any better, but I don’t have any complaints with it. Some vim plugins are so essential that I have no idea how people manage without them. A couple of essential starting points are:</p>
<ul>
<li><a href="https://github.com/tpope/vim-commentary">vim-commentary</a>: Quickly comment out things in any language</li>
<li><a href="https://github.com/tpope/vim-surround">vim-surround</a>: Surround a text object with delimiters</li>
<li><a href="https://github.com/tpope/vim-repeat">vim-repeat</a>: Lets you repeat plugins which support it by pressing <code>.</code></li>
<li><a href="https://github.com/junegunn/rainbow_parentheses.vim">rainbow_parentheses</a>: Make matching characters change colors as they become more nested. As a matter of fact, while typing this sentence I noticed that one of my previous links was unmatched because all of a sudden my other links changed colors. Super useful, especially for lisp-y languages.</li>
<li><a href="https://github.com/Julian/vim-textobj-variable-segment">textobj-variable-segment</a>: Target individual sections of camelCase and snake_case identifiers. This is probably the plugin I use the most often.</li>
</ul>
<p>Once you’ve finished with this section, call <code>:PlugInstall</code> to install your new plugins.</p>
<p>While I have you here, working on your .vimrc, I’d also add the boiler-plate removing stuff I mentioned yesterday. I’ll reproduce it here so as to inflate my word count, if not my page-view count by making you read it again.</p>
<pre class="viml"><code>&quot; Edit .vimrc
nnoremap &lt;leader&gt;ev :e ~/.vimrc&lt;CR&gt;

&quot; Reload any changes whenever you save .vimrc
augroup automaticallySourceVimrc
  au!
  au bufwritepost .vimrc source ~/.vimrc
augroup END</code></pre>
<p>I’ve also added this command which quickly inserts plugin entries for me:</p>
<pre class="viml"><code>&quot; Insert vim-plug style plugins from the system clipboard
nnoremap &lt;leader&gt;pg o&lt;ESC&gt;&quot;+pkddA&#39;&lt;ESC&gt;0iPlug &#39;&lt;ESC&gt;0</code></pre>
<p>This is probably enough infrastructure to get you going. Again, the point here is to minimize any friction you might have when trying to make changes to vim. As a bonus exercise, try adding a leader command to run <code>:PlugInstall</code> to update your plugins for you. Hint: <code>&lt;CR&gt;</code> is how you press enter.</p>
<h2 id="essential-attitude">Essential Attitude</h2>
<p>Here’s the kicker. This is the section that will really begin to help you improve. The essential attitude you need to develop is to <strong>hate repeating yourself</strong>. You need to hate doing repetitive things. Every time you find yourself pressing the same few keys in succession, ask yourself whether it would be amenable to abstracting. It usually will be.</p>
<p>If the keys you’re pressing are unlikely to be necessary ever again (some kind of specific formatting, usually), consider a macro: press <code>qx</code>, where ‘x’ is any letter you please, and then make a single one of the repetitive edits you need to make. When you’re done, hit <code>q</code> again. Now you can type <code>@x</code> to have vim press that exact sequence of keys for you again.</p>
<p>Wrapping your mind around which kinds of things work well in macros (hint, not <code>hjkl</code> or doing anything in insert mode other than <em>inserting</em>) takes a lot of work, but is definitely worth the effort. Expect your first hundred macros to mess up on at least one of the edits you’re trying to make, but they’ll get better quickly enough. I use a macro ever hour or so; you can do the math on how many days of work it’ll take you to get up to speed on them.</p>
<p>On the other hand, if the edits you’re making are likely to generalize, add a leader command to your .vimrc. Give them a mnemonic name that is short, but related to what thought goes through your head when you think “oh, I need to do <span class="math inline"><em>x</em></span> to this.”</p>
<p>The essential attitude, actually generalizes a little harder than just <em>hate repeating yourself</em> to <strong>hate when vim doesn’t do what you want</strong>. If you find yourself accidentally hitting the wrong key all of the time, consider mapping that key to do the thing you were actually trying to press. Consider mapping both the super annoying keys <code>&lt;F1&gt;</code> and <code>Q</code> to <code>&lt;nop&gt;</code> (the do-nothing key), because you’ll inevitably hit them and it will disrupt your flow.</p>
<p>The possibilities here are endless, but the attitude is simple: take a minute every time something annoys you to ensure it never annoys you again. Over a surprisingly short period of time, these changes will add up into that optimal editor I was talking about yesterday. It’s an incremental process, and this is how it happens.</p>
<p>It also helps if you become passionate about making the ideal editor. Once you have the drive, you’ll find yourself <a href="https://github.com/search?q=.vimrc">cruising around github</a> looking through other people’s .vimrcs for little snippets you can steal and make your experience that much better.</p>
<p>Anyway, I think that’s probably enough rambling about vim for today. That’s really all I have to say about vim for at least a week, but if you <em>really need more</em>, I’d recommend watching Ben Orenstein’s <a href="https://www.youtube.com/watch?v=SkdrYWhh-8s">video</a>. A lot of the ideas I’ve presented here were originally taken from there, but I think his presentation is better (as he probably didn’t write it stream-of-consciousness with a minimal amount of editing.)</p>
<hr />
<p>But before I go, lest you think that my claims in yesterday’s post were hyperbole, here’s a good example of a change I made to my .vimrc while writing this post:</p>
<pre class="viml"><code>imap \m &lt;ESC&gt;maT]y$}o&lt;ESC&gt;p0ys$]A:&lt;ESC&gt;&#39;a$T]ys$]A</code></pre>
<p>It’s disgusting; I know. Unforuntately until you’re really good at vim (and even then, one could argue), vim mappings have a tendency to be <em>write-only</em>. Let’s break it down:</p>
<ul>
<li><code>imap</code>: make a <em>recursive</em> binding in insert mode</li>
<li><code>\m</code>: bound to pressing <code>\m</code></li>
<li><code>&lt;ESC&gt;</code>: leave insert mode</li>
<li><code>ma</code>: set mark <span class="math inline"><em>a</em></span> where my cursor currently is, so we can come back later</li>
<li><code>T]</code>: move the cursor backwards to the previous ‘]’ character</li>
<li><code>y$</code>: yank the remainder of the line</li>
<li><code>}}</code>: move down two paragraphs (the end of this one, and then the end of my links section)</li>
<li><code>o&lt;ESC&gt;</code>: make a new line</li>
<li><code>p0</code>: paste the anchor name, and move to the beginning of the line</li>
<li><code>ys$]</code>: surround the line with square brackets (via <a href="https://github.com/tpope/vim-surround">vim-surround</a>)</li>
<li><code>A:&lt;ESC&gt;</code>: append a ‘:’ to the end of the line</li>
<li><code>'a</code>: move back to mark <span class="math inline"><em>a</em></span> (where our cursor was when we called the function)</li>
<li><code>$T]</code>: move again to the previous ‘]’ character</li>
<li><code>ys$]</code>: surround the anchor with square brackets</li>
<li><code>A</code>: and finally, move back to insert mode at the end of the line</li>
</ul>
<p>I mean, it’s not the world’s most efficient vim command, but it gets the job done and it’s the first thing that came to my mind. I’m not saying it’ll win any <a href="http://www.vimgolf.com/">games of golf</a>, but then again, I’m not playing any.</p>
<p>Later, for that list of plugins, I wrote a couple of link texts with their desired anchors in a list like this: ‘- [text]anchor’, and then pressed <code>vip:norm A\m</code> to generate anchors links for each one.</p>
<p>The point is not to demonstrate how clever I am at vim, but rather to show you how low my repetition tolerance is. That’s the essential attitude. Internalize it, and you can do great things.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This is not an exaggeration; it was my contingency plan to beef up my word count should I need it.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</article>

      </div>
    </div>
    </div>

        <div class="comments">
<script src="https://utteranc.es/client.js"
        repo="isovector/sandymaguire.me"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>

    </div>
    </div>
  </body>
</html>
